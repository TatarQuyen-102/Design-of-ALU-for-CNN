$date
	Mon Mar 31 11:20:19 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module tb_sqrt_csa_bec $end
$var wire 10 ! Out [9:0] $end
$var reg 9 " A [8:0] $end
$var reg 9 # B [8:0] $end
$var reg 1 $ Cin $end
$scope module uut $end
$var wire 9 % A [8:0] $end
$var wire 9 & B [8:0] $end
$var wire 1 ' Cin $end
$var wire 10 ( Out [9:0] $end
$var wire 3 ) o_rsa_2bit [2:0] $end
$var wire 4 * o_rsa_3bit [3:0] $end
$var wire 4 + o_rsa_3bit_add [3:0] $end
$var wire 4 , o_rsa_3bit_sub [3:0] $end
$var wire 5 - o_rsa_4bit [4:0] $end
$var wire 5 . o_rsa_4bit_add [4:0] $end
$var wire 5 / o_rsa_4bit_sub [4:0] $end
$scope module rsa_2bit $end
$var wire 2 0 A [1:0] $end
$var wire 2 1 B [1:0] $end
$var wire 2 2 B_xor [1:0] $end
$var wire 1 ' Cin $end
$var wire 1 3 Cout $end
$var wire 2 4 Sum [1:0] $end
$var wire 3 5 carry [2:0] $end
$var wire 1 6 carry_sign $end
$scope begin adder_stage[0] $end
$scope module FA $end
$var wire 1 7 A $end
$var wire 1 8 B $end
$var wire 1 9 Cin $end
$var wire 1 : Cout $end
$var wire 1 ; Sum $end
$upscope $end
$upscope $end
$scope begin adder_stage[1] $end
$scope module FA $end
$var wire 1 < A $end
$var wire 1 = B $end
$var wire 1 > Cin $end
$var wire 1 ? Cout $end
$var wire 1 @ Sum $end
$upscope $end
$upscope $end
$upscope $end
$scope module rsa_3bit $end
$var wire 3 A A [2:0] $end
$var wire 3 B B [2:0] $end
$var wire 3 C B_xor [2:0] $end
$var wire 1 D Cin $end
$var wire 1 E Cout $end
$var wire 3 F Sum [2:0] $end
$var wire 4 G carry [3:0] $end
$var wire 1 H carry_sign $end
$scope begin adder_stage[0] $end
$scope module FA $end
$var wire 1 I A $end
$var wire 1 J B $end
$var wire 1 K Cin $end
$var wire 1 L Cout $end
$var wire 1 M Sum $end
$upscope $end
$upscope $end
$scope begin adder_stage[1] $end
$scope module FA $end
$var wire 1 N A $end
$var wire 1 O B $end
$var wire 1 P Cin $end
$var wire 1 Q Cout $end
$var wire 1 R Sum $end
$upscope $end
$upscope $end
$scope begin adder_stage[2] $end
$scope module FA $end
$var wire 1 S A $end
$var wire 1 T B $end
$var wire 1 U Cin $end
$var wire 1 V Cout $end
$var wire 1 W Sum $end
$upscope $end
$upscope $end
$upscope $end
$scope module rsa_4bit $end
$var wire 4 X A [3:0] $end
$var wire 4 Y B [3:0] $end
$var wire 4 Z B_xor [3:0] $end
$var wire 1 [ Cin $end
$var wire 1 \ Cout $end
$var wire 4 ] Sum [3:0] $end
$var wire 5 ^ carry [4:0] $end
$var wire 1 _ carry_sign $end
$scope begin adder_stage[0] $end
$scope module FA $end
$var wire 1 ` A $end
$var wire 1 a B $end
$var wire 1 b Cin $end
$var wire 1 c Cout $end
$var wire 1 d Sum $end
$upscope $end
$upscope $end
$scope begin adder_stage[1] $end
$scope module FA $end
$var wire 1 e A $end
$var wire 1 f B $end
$var wire 1 g Cin $end
$var wire 1 h Cout $end
$var wire 1 i Sum $end
$upscope $end
$upscope $end
$scope begin adder_stage[2] $end
$scope module FA $end
$var wire 1 j A $end
$var wire 1 k B $end
$var wire 1 l Cin $end
$var wire 1 m Cout $end
$var wire 1 n Sum $end
$upscope $end
$upscope $end
$scope begin adder_stage[3] $end
$scope module FA $end
$var wire 1 o A $end
$var wire 1 p B $end
$var wire 1 q Cin $end
$var wire 1 r Cout $end
$var wire 1 s Sum $end
$upscope $end
$upscope $end
$upscope $end
$scope module bec_rsa_3bit $end
$var wire 4 t B [3:0] $end
$var wire 4 u B_not [3:0] $end
$var wire 4 v X [3:0] $end
$upscope $end
$scope module bec_rsa_4bit $end
$var wire 2 w AND_out [1:0] $end
$var wire 5 x B [4:0] $end
$var wire 5 y B_not [4:0] $end
$var wire 5 z X [4:0] $end
$upscope $end
$scope module mux_rsa_3bit $end
$var wire 4 { In0 [3:0] $end
$var wire 4 | In1 [3:0] $end
$var wire 4 } Out [3:0] $end
$var wire 1 ~ Sel $end
$upscope $end
$scope module mux_rsa_4bit $end
$var wire 5 !" In0 [4:0] $end
$var wire 5 "" In1 [4:0] $end
$var wire 5 #" Out [4:0] $end
$var wire 1 $" Sel $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
0$"
b0 #"
b0 ""
b0 !"
1~
b11 }
b11 |
b1101 {
b0 z
b11111 y
b0 x
b11 w
b11 v
b10 u
b1101 t
0s
0r
0q
0p
0o
0n
0m
0l
0k
0j
0i
0h
0g
0f
0e
0d
0c
0b
0a
0`
0_
b0 ^
b0 ]
0\
0[
b0 Z
b0 Y
b0 X
1W
1V
1U
1T
1S
0R
1Q
0P
1O
1N
1M
0L
0K
0J
1I
1H
b1100 G
b101 F
1E
0D
b110 C
b110 B
b111 A
0@
1?
0>
1=
1<
1;
0:
09
18
07
16
b100 5
b1 4
13
b11 2
b11 1
b10 0
b0 /
b0 .
b0 -
b11 ,
b1101 +
b11 *
b101 )
b1101 (
0'
b11011 &
b11110 %
0$
b11011 #
b11110 "
b1101 !
$end
#10
1\
0~
b0 *
b0 }
1_
03
b0 ,
b0 v
b0 |
0E
b11 w
b10000 /
b10000 z
b10000 ""
1r
b10000 ^
06
0U
0H
0;
0?
b0 5
0Q
b1111 u
0V
b0 G
b1111 y
b1000000000 !
b1000000000 (
b10000 -
b10000 #"
0@
b0 )
b0 4
0M
0R
0W
b0 +
b0 t
b0 {
b0 F
0s
b10000 .
b10000 x
b10000 !"
b0 ]
08
0=
0O
0T
1p
b0 2
b0 C
b1000 Z
0<
0I
0N
0S
1o
b0 1
b0 B
b1000 Y
b0 0
b0 A
b1000 X
b100000000 #
b100000000 &
b100000000 "
b100000000 %
#20
16
1$"
1?
1E
1s
b1110 *
b1110 }
1P
1U
1H
1g
1l
1q
b10 ,
b10 v
b10 |
b10 /
b10 z
b10 ""
b0 w
1L
1Q
1V
b1110 G
1c
1h
1m
b11110 ^
1>
b1 u
b1 y
b10 -
b10 #"
1:
0@
0M
1R
1W
b1110 +
b1110 t
b1110 {
b110 F
0d
1i
1n
b11110 .
b11110 x
b11110 !"
b1110 ]
b1011000 !
b1011000 (
1J
1O
1T
1a
1f
1k
0;
b0 4
0~
b111 C
b1111 Z
17
1<
1I
1N
1S
1`
1e
1j
19
03
b0 )
b11 1
b111 B
b1111 Y
b11 0
b111 A
b1111 X
1$
1'
b111 5
b111111111 #
b111111111 &
b111111111 "
b111111111 %
#30
0s
0q
0m
0l
0h
0W
0U
0Q
b1001 -
b1001 #"
0g
b101 ,
b101 v
b101 |
b1001 /
b1001 z
b1001 ""
0c
b10000 ^
0P
b100101110 !
b100101110 (
1@
b10 )
b10 4
1d
1i
0L
b1000 G
b100 u
b1011 *
b1011 }
b1000 y
1M
1R
b1011 +
b1011 t
b1011 {
b11 F
1n
b10111 .
b10111 x
b10111 !"
b111 ]
1=
0a
0f
b10 2
b1100 Z
0I
0N
0j
b1 1
b1100 Y
b100 A
b1011 X
b110011101 #
b110011101 &
b101110011 "
b101110011 %
#40
