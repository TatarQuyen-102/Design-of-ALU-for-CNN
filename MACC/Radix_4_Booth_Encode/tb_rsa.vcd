$date
	Sat Mar 29 11:22:19 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module tb_rsa $end
$var wire 1 ! Cout $end
$var wire 4 " Sum [3:0] $end
$var reg 4 # A [3:0] $end
$var reg 4 $ B [3:0] $end
$var reg 1 % Cin $end
$scope module dut $end
$var wire 4 & A [3:0] $end
$var wire 4 ' B [3:0] $end
$var wire 4 ( B_xor [3:0] $end
$var wire 1 ) Cin $end
$var wire 1 ! Cout $end
$var wire 4 * Sum [3:0] $end
$var wire 5 + carry [4:0] $end
$var wire 1 , carry_sign $end
$scope begin adder_stage[0] $end
$scope module FA $end
$var wire 1 - A $end
$var wire 1 . B $end
$var wire 1 / Cin $end
$var wire 1 0 Cout $end
$var wire 1 1 Sum $end
$upscope $end
$upscope $end
$scope begin adder_stage[1] $end
$scope module FA $end
$var wire 1 2 A $end
$var wire 1 3 B $end
$var wire 1 4 Cin $end
$var wire 1 5 Cout $end
$var wire 1 6 Sum $end
$upscope $end
$upscope $end
$scope begin adder_stage[2] $end
$scope module FA $end
$var wire 1 7 A $end
$var wire 1 8 B $end
$var wire 1 9 Cin $end
$var wire 1 : Cout $end
$var wire 1 ; Sum $end
$upscope $end
$upscope $end
$scope begin adder_stage[3] $end
$scope module FA $end
$var wire 1 < A $end
$var wire 1 = B $end
$var wire 1 > Cin $end
$var wire 1 ? Cout $end
$var wire 1 @ Sum $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
0@
0?
0>
0=
0<
1;
0:
19
08
07
06
15
14
03
12
01
10
0/
1.
1-
0,
b110 +
b100 *
0)
b1 (
b1 '
b11 &
0%
b1 $
b11 #
b100 "
0!
$end
#10000
1@
04
1>
06
00
1:
b1100 +
11
0;
b1001 "
b1001 *
13
b11 (
0-
17
b11 $
b11 '
b110 #
b110 &
#20000
1>
1:
0;
19
1!
15
14
1,
06
10
1?
b11110 +
01
0@
b0 "
b0 *
03
b1 (
1-
1<
b1 $
b1 '
b1111 #
b1111 &
#30000
04
09
11
0;
00
05
06
0@
b1 "
b1 *
0.
18
1=
1/
0!
b1100 (
0-
02
0<
1%
b11001 +
1)
b11 $
b11 '
b100 #
b100 &
#40000
19
15
14
0>
01
10
06
0:
b10111 +
1;
0@
b100 "
b100 *
1.
13
08
b1011 (
07
1<
b100 $
b100 '
b1000 #
b1000 &
#50000
09
05
16
1!
04
0>
0,
11
00
1;
0:
0?
b1 +
1@
b1111 "
b1111 *
0.
18
b1110 (
0<
b1 $
b1 '
b0 #
b0 &
#60000
